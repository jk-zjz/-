#include <stdio.h>
#include <string.h>
#define _CRT_SECURE_NO_WARNINGS 1
/*
C语言类型：
1.内置类型
int 
char
short
long
long long
double
float
2.自定义类型（构造类型） 
*/
//int main()
//{
//	int a=10;//向内存申请4个字节
//	float b=10.0;//向内存申请4个字节
//	
//	short a=10;
//	short int b=10;//int 可省略
//	return 0;
//}
//&a在内存的存储形式-->0a 00 00 00
//&b在内存的存储形式-->00 00 20 41

//类型决定开辟空间的大小
//类型也决定了开待内存空间的视角


/*
整形家族：
char
	unsignde char //无符号数 列：11111111=255
	signed char  //有符号数吧最高数变成符号，0是正 1是负 列：11111111=127
short
	unsignde short
	signed short
int
	unsignde int
	signed int
long
	unsignde long
	signed long
*/

/*
浮点型家族
float   单精度

double   双精度

*/


/*
构造类型：

数组类型---->int arr[10]   int[5]!=char[5]
结构体类型struct--->成员在变结构体也在变
枚举类型enum
联合类型union

*/

/*
指针类型

int *
char *
float *
void *

*/

/*
空类型
void 用在函数返回值，函数参数，指针类型
*/


//整形的存储过程

//int main(){
//	int a=10;//内存的存储-->0a 00 00 00
//	int b=-5;//内存的存储-->ec ff ff ff
//	return 0;
//}
//放进去的是   原码 -->反码--->补码（内存）
//正数 原码=反码=补码
//负数  原码-->反码（1,0 取反）-->加1
//列：-5----10000000 00000000 00000000 00000101
//反码----11111111 11111111 11111111 11111010 
//补码----11111111 11111111 11111111 11111011


//  CPU只会处理加法：
//列:1-1 ---> 在cpu哪里结束1+（-1），用的是补码计算，因为源码有问题

//为什么在内存里面存储是反的
/*

大端（模式）数据的低位放地址高位
小端（模式）数据的高位放高地址位

*/

//判断这个机型是小端还是大端
//列 a=1
//小-->10 00 00 00
//大-->00 00 00 01
//int check_sys(){
//	int a=1;
//	return *(char *)&a;//强制类型转化char*
//	//返回1，小
//	//返回，大
//}
//int main(){
//	int a=1;
//	int o=check_sys();
//	if(a==1){
//		printf("小");
//	}else{
//		printf("大");
//	}
//return 0;
//}



//int main(){
//	char a=-1;
//	signed char b=-1;
//	unsigned char c=-1;
//	printf("%d %d %d",a,b,c);
//return 0;
//}
/*

char a 是一个char类型打印的时候要进行整形提升
char a-->11111111
整形提升--->11111111 11111111 11111111 11111111 补码
高位补1

unsigned char c--->11111111
是一个无符号整形提升补0
00000000 00000000 00000000 11111111
原反补相同=255

*/


//int main(){
//	char a=-128;
//	printf("%u",a);
//
//return 0;
//}

/*
-128-->10000000
10000000 00000000 00000000 10000000原
11111111 11111111 11111111 01111111反
11111111 11111111 11111111 10000000补

char类型截取----100000000
整形提升：
最高位---11111111 11111111 11111111 100000000
无符号打印：4,294,967,168

一个有符号char范围 -128--127
无符号   0-255
*/


//int main(){
//	char a=128;
//	printf("%u",a);
//
//return 0;
//}

/*
正数原反补相同
128--> 截取 10000000
整形提升-->11111111 11111111 11111111 100000000
还是4,294,967,168
*/


//int main(){
//	int a=-20;
//	unsigned int j=10;
//	printf("%d",a+j);
//return 0;
//}

/*
a-->
10000000 00000000 00000000 00010100 原
11111111 11111111 11111111 11101011 反
11111111 11111111 11111111 11101100 补

j-->
00000000 00000000 00000000 00001010


a+j
11111111 11111111 11111111 11101100
00000000 00000000 00000000 00001010

11111111 11111111 11111111 11110110结果补码
11111111 11111111 11111111 11110101反码
10000000 00000000 00000000 00001010打印结果
=-10

*/


//int main(){
//	unsigned int i;
//	for(i=9;i>=0;i--){
//		printf("%u",i);
//	}
//return 0;
//}

/*
死循环
i永远不小于0
因为i是一个无符号数吧最高位看成了值不少符号
*/

//int main(){
//char a[1000];
//int i;
//for(i=0;i<1000;i++){
//a[i]=-1-i;
//
//}
//printf("%d",strlen(a));//255
//return 0;
//}
/*
i++
1,2,3.......1000循环1000次
但是放的是char类型的数组里面
所以要截取-1-0=-1
char截取所以存入的是-1，-2，-3.....-128，128...3,2,1,0,-1...-128...
strlen 是计算到\0结束  \0的ASCII是0
所以截取到-1------3,2,1,0
中间有255个数

*/


//int main(){
//	unsigned char i=0;
//	for(i=0;i<=255;i++){
//	printf("ss");	
//
//	}
//return  0;
//}
//死循环





//浮点型在内存的存储

//int main(){
//	int a=9; 
//	float *pf=(float *)&a;
//	printf("%d\n",a);
//	printf("%f\n",*pf);
//
//	*pf=9.0;
//	printf("%d\n",a);
//	printf("%f\n",*pf);
//return 0;
//}

//int main(){
//	float a=5.5;
//
//
//return 0;
//}

/*
算法

float a=5.5;
1. 101.1-----转换为二进制，小数点后面也要转
2. (-1)^S * M * 2^E---S为正负数正为0,M是转化的二进制，E是小数点前面的指数
3. (-1)^0 * 1.011 * 2^2
S  占1位
M  占23位
E  占8位
内存：0  2+127 011
补齐  0  10000001  01100000000000000000000

会分3段存入内存
第一段 M段，因为这个数大小永远在  1<=  >2 所以在内存中存入的只有小数点后面的数列  
    0.5化为二进制为 0.1在内存，存的是1
第二段E 是一个无符号数，都是会有负数比如：2^-1所以要加一个中间值127 =-1+127=126
双精度中间值为1023

*/

/*
拿出：
分3种情况


E全0：
0  00000000  01100000000000000000000
直接规定为
+-  * 0.011 * 2^-126  无限接近0

E全1的时候
+- * 1.011 *2^128   无限大的数字


*/


int main(){
	int a=9; 
	//源码：00000000 00000000 00000000 00001001
	float *pf=(float *)&a;
	printf("%d\n",a);//以整形放进去整形拿出来
	printf("%f\n",*pf);//整形放进去，浮点拿出来
	//0 00000000 00000000000000000001001
	//为全0
	// + * 1.00000000000000000001001 * 2^-126  无限接近0
	*pf=9.0;//用浮点存入
	//(-1)^0 * 1.001 * 2^3   2^(3+127)
	// 0 10000010 00100000000000000000000
	printf("%d\n",a);//1,091,567,616
	//打印   01000001000100000000000000000000
	printf("%f\n",*pf);//9.000000
	//以浮点 0 10000010 00100000000000000000000
return 0;
}




